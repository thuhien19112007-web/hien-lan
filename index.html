<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Infinity Birthday Galaxy & Lucky Wheel</title>
    <style>
        /* GI·ªÆ NGUY√äN CSS C≈® */
        body { margin: 0; background: #000; overflow: hidden; touch-action: none; font-family: 'Segoe UI', Arial, sans-serif; }
        #instruction {
            position: absolute; top: 5%; width: 100%; text-align: center;
            color: #00ffff; font-family: 'Arial', sans-serif; 
            letter-spacing: 2px; font-size: 10px; opacity: 0.8; z-index: 10;
            text-shadow: 0 0 10px #00ffff; transition: all 1s ease;
        }
        #nextToWheel {
            position: absolute; bottom: 10%; left: 50%; transform: translateX(-50%);
            padding: 12px 25px; background: transparent; border: 2px solid #00ffff;
            color: #00ffff; border-radius: 25px; cursor: pointer; z-index: 20;
            display: none; text-shadow: 0 0 5px #00ffff; box-shadow: 0 0 10px #00ffff;
        }
        :root { --neon-pink: #ff0055; --neon-blue: #00f2ff; --gold: #ffcc00; }
        #screen2 {
            display: none; flex-direction: column; align-items: center; justify-content: center;
            height: 100vh; width: 100vw; background: radial-gradient(circle, #1a1a2e, #0a0a12);
            color: white; position: absolute; top: 0; left: 0; z-index: 100;
        }
        .title { font-size: 1.5rem; font-weight: bold; text-transform: uppercase; letter-spacing: 3px; color: #fff; text-shadow: 0 0 15px var(--neon-pink); margin-bottom: 25px; text-align: center; }
        .wheel-container { position: relative; padding: 15px; border-radius: 50%; background: #111; box-shadow: 0 0 40px rgba(0,0,0,0.8); }
        .led-ring { position: absolute; width: 100%; height: 100%; top: 0; left: 0; border-radius: 50%; border: 2px solid #222; }
        .wheel-box { position: relative; width: 88vw; height: 88vw; max-width: 360px; max-height: 360px; }
        .pointer { position: absolute; top: -15px; left: 50%; transform: translateX(-50%); width: 35px; height: 45px; z-index: 100; filter: drop-shadow(0 0 5px var(--neon-pink)); transition: transform 0.05s; }
        #wheel { border: 8px solid #222; border-radius: 50%; width: 100%; height: 100%; display: block; box-shadow: inset 0 0 20px rgba(0,0,0,0.5); }
        .controls { margin-top: 30px; }
        #spinBtn { padding: 15px 50px; font-size: 1.3rem; font-weight: 800; color: #fff; background: linear-gradient(45deg, var(--neon-pink), var(--gold)); border: none; border-radius: 50px; cursor: pointer; box-shadow: 0 0 20px rgba(255, 0, 85, 0.4); transition: 0.2s; }
        #spinBtn:disabled { filter: grayscale(1); opacity: 0.5; }
        #result { margin-top: 20px; font-size: 1.2rem; font-weight: bold; color: var(--neon-blue); text-align: center; height: 1.5em; text-shadow: 0 0 10px rgba(0, 242, 255, 0.4); }
        .confetti { position: absolute; z-index: 1000; pointer-events: none; }
    </style>
</head>
<body>

    <audio id="bgMusic" loop preload="auto">
        <source src="https://files.catbox.moe/8f31c6.mp3" type="audio/mpeg">
    </audio>

    <audio id="tickSound" preload="auto">
        <source src="https://www.soundjay.com/buttons/button-50.mp3" type="audio/mpeg">
    </audio>
    <audio id="congratsSound" preload="auto">
        <source src="https://assets.mixkit.co/active_storage/sfx/2013/2013-preview.mp3" type="audio/mpeg">
    </audio>

    <div id="instruction">V≈® TR·ª§ ƒêANG CHU·∫®N B·ªä M√ìN QU√Ä...</div>
    <button id="nextToWheel" onclick="showWheelScreen()">NH·∫¨N QU√Ä SINH NH·∫¨T ‚ú®</button>

    <div id="screen2">
        <div class="title">üé° V√íNG QUAY MAY M·∫ÆN üé°</div>
        <div class="wheel-container">
            <div id="leds" class="led-ring"></div>
            <div class="wheel-box">
                <svg class="pointer" viewBox="0 0 40 50">
                    <path d="M20 50 L40 10 Q20 0 0 10 Z" fill="#ffcc00" stroke="#fff" stroke-width="2"/>
                </svg>
                <canvas id="wheel" width="360" height="360"></canvas>
            </div>
        </div>
        <div id="result">B·∫•m QUAY ƒë·ªÉ th·ª≠ v·∫≠n may!</div>
        <div class="controls">
            <button id="spinBtn" onclick="initSpin()">QUAY!</button>
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { FontLoader } from 'three/addons/loaders/FontLoader.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';

        let scene, camera, renderer, composer, lineMesh, headLight, stars;
        let points = [], progress = 0;
        let photoGroup, shootingStars = [], birthdayIcons = [];
        let isDrawingFinished = false;
        let isZoomed = false;
        let touchStartX = 0;

        // X·ª≠ l√Ω t·ª± ƒë·ªông ph√°t nh·∫°c khi t∆∞∆°ng t√°c
        const playMusic = () => {
            const music = document.getElementById('bgMusic');
            music.play().catch(() => {});
            // G·ª° b·ªè event sau khi ƒë√£ ph√°t nh·∫°c th√†nh c√¥ng ƒë·ªÉ tr√°nh l·∫∑p l·∫°i
            document.removeEventListener('mousedown', playMusic);
            document.removeEventListener('touchstart', playMusic);
            document.removeEventListener('keydown', playMusic);
        };
        document.addEventListener('mousedown', playMusic);
        document.addEventListener('touchstart', playMusic);
        document.addEventListener('keydown', playMusic);

        const imageURLs = [
            "https://i.ibb.co/fYyBMxjk/f7e3404c-fcb0-4653-be53-0c26d5dca024.jpg",
            "https://i.ibb.co/mFXLRP2V/9d239072-d64a-4050-a1a9-8c530e78b336.jpg",
            "https://i.ibb.co/Y4TZ5WJK/6ac5719a-88c8-4cb4-a0c2-a75106c69e08.jpg",
            "https://i.ibb.co/TDy81zdq/cb6e49e3-b014-4680-830e-a03d7965c067.jpg",
            "https://i.ibb.co/cKBRfgVK/40623cfd-100a-48d9-ab0e-ed19cfe167b8.jpg",
            "https://i.ibb.co/fYyBMxjk/f7e3404c-fcb0-4653-be53-0c26d5dca024.jpg",
            "https://i.ibb.co/TDy81zdq/cb6e49e3-b014-4680-830e-a03d7965c067.jpg",
            "https://i.ibb.co/Y7d8nQPz/0a6eceec-979d-49fb-8880-5a9fc7460870.jpg",
            "https://i.ibb.co/hxB3wjnx/602ce2db-54e1-42f2-a84e-ad8d62716495.jpg",
            "https://i.ibb.co/WNm3Z4qF/ea686239-4f36-43a9-803d-3a6350d39225.jpg",
            "https://i.ibb.co/sdw4TncR/a9fa43de-3a3e-478b-8387-206c8754d260.jpg",
            "https://i.ibb.co/bgCh1F8H/3a983ba0-fb1c-41b4-b3c7-a67513102602.jpg",
            "https://i.ibb.co/Y4TZ5WJK/6ac5719a-88c8-4cb4-a0c2-a75106c69e08.jpg",
            "https://i.ibb.co/bgCh1F8H/3a983ba0-fb1c-41b4-b3c7-a67513102602.jpg",
            "https://i.ibb.co/TDy81zdq/cb6e49e3-b014-4680-830e-a03d7965c067.jpg",
            "https://i.ibb.co/WNm3Z4qF/ea686239-4f36-43a9-803d-3a6350d39225.jpg",
            "https://i.ibb.co/fz4tJrm8/2fad8aa8-5dd2-41c7-b45a-98f1423838d2.jpg",
            "https://i.ibb.co/hxB3wjnx/602ce2db-54e1-42f2-a84e-ad8d62716495.jpg",
            "https://i.ibb.co/bgCh1F8H/3a983ba0-fb1c-41b4-b3c7-a67513102602.jpg",
            "https://i.ibb.co/vvHxTfZ7/26aab1ed-b692-4f83-9601-0c37018a4fce.jpg"
        ];

        const photoCount = imageURLs.length;
        const getCameraZ = (zoomed) => {
            const isMobile = window.innerWidth < window.innerHeight;
            if (zoomed) return isMobile ? 65 : 45; 
            return isMobile ? 120 : 85;
        };

        init();

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.position.z = getCameraZ(false);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.toneMapping = THREE.CineonToneMapping;
            document.body.appendChild(renderer.domElement);
            const renderPass = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 0.6, 0.4, 0.5);
            composer = new EffectComposer(renderer);
            composer.addPass(renderPass);
            composer.addPass(bloomPass);
            createStars();
            headLight = new THREE.Mesh(new THREE.SphereGeometry(0.7, 16, 16), new THREE.MeshBasicMaterial({ color: new THREE.Color(2, 2, 2) }));
            scene.add(headLight);
            const loader = new FontLoader();
            loader.load('https://unpkg.com/three@0.160.0/examples/fonts/helvetiker_bold.typeface.json', (font) => {
                const isMobile = window.innerWidth < window.innerHeight;
                const shapes = font.generateShapes('Happy Birthday', isMobile ? 6 : 10);
                shapes.forEach(shape => {
                    const shapePoints = shape.getSpacedPoints(250); 
                    shapePoints.forEach(p => points.push(new THREE.Vector3(p.x, p.y, 0)));
                });
                const lineGeo = new THREE.BufferGeometry().setFromPoints(points);
                lineGeo.center();
                const glowColor = new THREE.Color(0x00ffff).multiplyScalar(1.2);
                lineMesh = new THREE.Line(lineGeo, new THREE.LineBasicMaterial({ color: glowColor, transparent: true, opacity: 0.9 }));
                lineMesh.geometry.setDrawRange(0, 0);
                scene.add(lineMesh);
                animate();
            });
            window.addEventListener('touchstart', e => touchStartX = e.touches[0].clientX);
            window.addEventListener('touchend', e => {
                const diff = e.changedTouches[0].clientX - touchStartX;
                if (diff > 40) isZoomed = true;
                if (diff < -40) isZoomed = false;
            });
            window.addEventListener('mousedown', e => touchStartX = e.clientX);
            window.addEventListener('mouseup', e => {
                const diff = e.clientX - touchStartX;
                if (diff > 30) isZoomed = true;
                if (diff < -30) isZoomed = false;
            });
        }

        function createStars() {
            const starGeo = new THREE.BufferGeometry();
            const posArray = new Float32Array(4000 * 3);
            for(let i=0; i < posArray.length; i++) posArray[i] = (Math.random() - 0.5) * 1500;
            starGeo.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
            stars = new THREE.Points(starGeo, new THREE.PointsMaterial({ color: 0xffffff, size: 1.2, transparent: true, opacity: 0.9, sizeAttenuation: true }));
            scene.add(stars);
        }

        function createBirthdayIcon() {
            const icons = ['üéÇ', '‚ú®', 'üéà', 'üéÅ', '‚≠ê', 'üç∞', 'üßÅ', 'üéä', 'üéâ'];
            const icon = icons[Math.floor(Math.random() * icons.length)];
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.font = '50px serif';
            ctx.fillText(icon, 5, 50);
            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.SpriteMaterial({ map: texture, transparent: true, opacity: 0.8 });
            const sprite = new THREE.Sprite(material);
            const isMobile = window.innerWidth < window.innerHeight;
            const spreadX = isMobile ? 120 : 250;
            const spreadZ = isMobile ? 80 : 150;
            sprite.position.set((Math.random() - 0.5) * spreadX, 120, (Math.random() - 0.5) * spreadZ);
            const scale = 1.5 + Math.random() * 2;
            sprite.scale.set(scale, scale, 1);
            sprite.userData = { speed: 0.3 + Math.random() * 0.6, rotSpeed: (Math.random() - 0.5) * 0.04 };
            scene.add(sprite);
            birthdayIcons.push(sprite);
        }

        function createShootingStar() {
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(2 * 3);
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const material = new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 1 });
            const line = new THREE.Line(geometry, material);
            const x = (Math.random() - 0.5) * 600;
            const y = 200 + Math.random() * 100;
            const z = (Math.random() - 0.5) * 200;
            line.userData = {
                vel: new THREE.Vector3((Math.random() > 0.5 ? -1 : 1) * (2 + Math.random() * 3), - (2 + Math.random() * 3), (Math.random() - 0.5) * 2),
                pos: new THREE.Vector3(x, y, z),
                len: 15 + Math.random() * 25
            };
            scene.add(line);
            shootingStars.push(line);
        }

        function startPhotoGalaxy() {
            photoGroup = new THREE.Group();
            const texLoader = new THREE.TextureLoader();
            const isMobile = window.innerWidth < window.innerHeight;
            const radius = isMobile ? 45 : 72;
            imageURLs.forEach((url, i) => {
                texLoader.load(url, (texture) => {
                    texture.colorSpace = THREE.SRGBColorSpace;
                    const aspect = texture.image.width / texture.image.height;
                    const baseSize = isMobile ? 14 : 16;
                    let planeW, planeH;
                    if (aspect > 1) { planeW = baseSize; planeH = baseSize / aspect; } 
                    else { planeH = baseSize; planeW = baseSize * aspect; }
                    const material = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide, transparent: true, opacity: 0, color: 0xcccccc });
                    const geometry = new THREE.PlaneGeometry(planeW, planeH);
                    const plane = new THREE.Mesh(geometry, material);
                    const theta = (i / photoCount) * Math.PI * 2;
                    const yPos = ((i % 3) - 1) * (isMobile ? 22 : 28); 
                    plane.userData.targetPos = new THREE.Vector3(Math.cos(theta) * radius, yPos, Math.sin(theta) * radius);
                    plane.userData.originalRotationY = -theta;
                    plane.position.set(plane.userData.targetPos.x * 2, plane.userData.targetPos.y, plane.userData.targetPos.z * 2);
                    plane.rotation.y = -theta; 
                    photoGroup.add(plane);
                });
            });
            scene.add(photoGroup);
        }

        function animate() {
            requestAnimationFrame(animate);
            if (stars) stars.rotation.y += 0.0001;
            camera.position.z = THREE.MathUtils.lerp(camera.position.z, getCameraZ(isZoomed), 0.06);
            if (Math.random() < 0.08) createShootingStar();
            for (let i = shootingStars.length - 1; i >= 0; i--) {
                const s = shootingStars[i];
                s.userData.pos.add(s.userData.vel);
                const p = s.userData.pos;
                const v = s.userData.vel.clone().normalize().multiplyScalar(s.userData.len);
                const positions = s.geometry.attributes.position.array;
                positions[0] = p.x; positions[1] = p.y; positions[2] = p.z;
                positions[3] = p.x - v.x; positions[4] = p.y - v.y; positions[5] = p.z - v.z;
                s.geometry.attributes.position.needsUpdate = true;
                s.material.opacity -= 0.01;
                if (s.userData.pos.y < -300 || s.material.opacity <= 0) {
                    scene.remove(s);
                    shootingStars.splice(i, 1);
                }
            }
            if (Math.random() < 0.25) createBirthdayIcon();
            for (let i = birthdayIcons.length - 1; i >= 0; i--) {
                const b = birthdayIcons[i];
                b.position.y -= b.userData.speed;
                b.material.rotation += b.userData.rotSpeed;
                if (b.position.y < -120) { scene.remove(b); birthdayIcons.splice(i, 1); }
            }
            if (lineMesh && progress < points.length) {
                progress += 6;
                lineMesh.geometry.setDrawRange(0, Math.floor(progress));
                const posAttr = lineMesh.geometry.attributes.position;
                const idx = Math.min(Math.floor(progress), posAttr.count - 1);
                headLight.position.set(posAttr.getX(idx), posAttr.getY(idx), posAttr.getZ(idx));
            } 
            else if (lineMesh && !isDrawingFinished) {
                isDrawingFinished = true;
                headLight.visible = false;
                document.getElementById('instruction').style.opacity = "0";
                setTimeout(() => {
                    document.getElementById('instruction').innerHTML = "‚ú® VU·ªêT PH·∫¢I ƒê·ªÇ PH√ìNG TO ‚ú®";
                    document.getElementById('instruction').style.opacity = "1";
                    document.getElementById('nextToWheel').style.display = "block";
                }, 1000);
                startPhotoGalaxy();
            }
            if (isDrawingFinished && photoGroup) {
                photoGroup.rotation.y += isZoomed ? 0.0005 : 0.0015; 
                photoGroup.children.forEach((child) => {
                    child.position.lerp(child.userData.targetPos, 0.05);
                    if (child.material.opacity < 1) child.material.opacity += 0.02;
                    const worldPos = new THREE.Vector3();
                    child.getWorldPosition(worldPos);
                    const triggerZ = isZoomed ? (window.innerWidth < window.innerHeight ? 20 : 35) : 50;
                    if (isZoomed && worldPos.z > triggerZ) {
                        child.rotation.y = THREE.MathUtils.lerp(child.rotation.y, -photoGroup.rotation.y, 0.1);
                    } else {
                        child.rotation.y = THREE.MathUtils.lerp(child.rotation.y, child.userData.originalRotationY, 0.1);
                    }
                });
            }
            composer.render();
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        window.showWheelScreen = function() {
            document.getElementById('screen2').style.display = 'flex';
            renderer.domElement.style.display = 'none';
            document.getElementById('instruction').style.display = 'none';
            document.getElementById('nextToWheel').style.display = 'none';
            drawWheel(); 
        }
    </script>

    <script>
        const canvas = document.getElementById("wheel");
        const ctx = canvas.getContext("2d");
        const resultText = document.getElementById("result");
        const spinBtn = document.getElementById("spinBtn");
        const pointer = document.querySelector(".pointer");
        const tickSound = document.getElementById("tickSound");
        const congratsSound = document.getElementById("congratsSound");
        
        const gifts = ["50K", "200K", "M·∫•t L∆∞·ª£t", "Qu√† B√≠ M·∫≠t", "100K", "20k", "1üç†", "500K"];
        const colors = ["#ff3d67", "#34495e", "#ff3d67", "#34495e", "#ff3d67", "#34495e", "#ff3d67", "#34495e"];
        
        let startAngle = 0;
        let isSpinning = false;
        let lastTickIndex = -1;

        function playTick() {
            tickSound.pause();
            tickSound.currentTime = 0;
            tickSound.play().catch(() => {});
            pointer.style.transform = "translateX(-50%) rotate(-20deg)";
            setTimeout(() => pointer.style.transform = "translateX(-50%) rotate(0deg)", 50);
        }

        function drawWheel() {
            const size = gifts.length;
            const arc = (2 * Math.PI) / size;
            ctx.clearRect(0, 0, 360, 360);
            gifts.forEach((gift, i) => {
                const angle = startAngle + i * arc;
                ctx.fillStyle = colors[i];
                ctx.beginPath(); ctx.moveTo(180, 180);
                ctx.arc(180, 180, 175, angle, angle + arc);
                ctx.fill();
                ctx.strokeStyle = "rgba(255,255,255,0.1)"; ctx.lineWidth = 2; ctx.stroke();
                ctx.save();
                ctx.fillStyle = "white"; ctx.font = "bold 16px Arial";
                ctx.translate(180 + Math.cos(angle + arc/2) * 115, 180 + Math.sin(angle + arc/2) * 115);
                ctx.rotate(angle + arc/2 + Math.PI/2);
                ctx.fillText(gift, -ctx.measureText(gift).width / 2, 0);
                ctx.restore();
            });
            ctx.beginPath(); ctx.arc(180, 180, 15, 0, Math.PI * 2); ctx.fillStyle = "#fff"; ctx.fill();
        }

        function initSpin() {
            if (isSpinning) return;
            spin();
        }

        function spin() {
            isSpinning = true;
            spinBtn.disabled = true;
            resultText.innerText = "üöÄ ƒêang xem v·∫≠n may...";
            const size = gifts.length;
            const arc = (2 * Math.PI) / size;
            const targetGiftIndex = 0; 
            const stopAngleAtTarget = (2 * Math.PI) - (targetGiftIndex * arc) - (arc / 2) - (Math.PI / 2);
            const backDistance = arc * 1.5; 
            const overshootAngle = stopAngleAtTarget + backDistance;
            const extraSpins = 10 * 2 * Math.PI;
            const currentRotation = startAngle % (2 * Math.PI);
            const totalToOvershoot = extraSpins + (overshootAngle - currentRotation + 4 * Math.PI) % (2 * Math.PI);
            const startTime = performance.now();
            const phase1Duration = 7000;
            const phase2Duration = 3000;
            const initialAngle = startAngle;

            function animate(now) {
                const elapsed = now - startTime;
                if (elapsed < phase1Duration) {
                    const p = elapsed / phase1Duration;
                    const easing = 1 - Math.pow(1 - p, 4);
                    startAngle = initialAngle + (totalToOvershoot * easing);
                } 
                else if (elapsed < phase1Duration + 500) {
                    resultText.innerText = "‚è≥ CH·ªú ƒê√É...";
                }
                else if (elapsed < phase1Duration + phase2Duration + 500) {
                    const p2 = Math.min((elapsed - phase1Duration - 500) / phase2Duration, 1);
                    const easingBack = p2 < 0.5 ? 2 * p2 * p2 : 1 - Math.pow(-2 * p2 + 2, 2) / 2;
                    startAngle = (initialAngle + totalToOvershoot) - (backDistance * easingBack);
                }

                const currentIndex = Math.floor((size - (startAngle / (2 * Math.PI) * size) % size + size) % size);
                if (currentIndex !== lastTickIndex) {
                    playTick();
                    lastTickIndex = currentIndex;
                }

                drawWheel();
                if (elapsed < phase1Duration + phase2Duration + 500) {
                    requestAnimationFrame(animate);
                } else {
                    isSpinning = false;
                    spinBtn.disabled = false;
                    resultText.innerHTML = "‚ú® üéÇ 50.000ƒë üéâ ‚ú®";
                    congratsSound.play().catch(() => {});
                    createConfetti();
                }
            }
            requestAnimationFrame(animate);
        }

        function createConfetti() {
            for(let i=0; i<40; i++) {
                const div = document.createElement('div');
                div.className = 'confetti';
                div.style.left = Math.random() * 100 + 'vw';
                div.style.backgroundColor = `hsl(${Math.random() * 360}, 100%, 50%)`;
                div.style.top = '-10px'; div.style.width = '10px'; div.style.height = '10px';
                document.body.appendChild(div);
                const fallDuration = 3000 + Math.random() * 2000;
                div.animate([
                    { transform: 'translateY(0) rotate(0)', opacity: 1 },
                    { transform: `translateY(100vh) rotate(${Math.random() * 720}deg)`, opacity: 0 }
                ], fallDuration);
                setTimeout(() => div.remove(), fallDuration);
            }
        }
    </script>
</body>
</html>
